%{
    #include <stdio.h>
    #include <stdlib.h>
    #include <string>
    #include <stdbool.h>
       
    #define YYERROR_VERBOSE 1        
%}

%code {
int yylex (void);
void yyerror ( const IProgram*&, char const * );
}

%error-verbose // более подробная информация об ошибке
%verbose // output-файл с правилами грамматики
%parse-param { const IProgram*& program } // результат работы анализатора
%locations  // Подключаем yylloc без появления @n в коде

%union {

	const CProgram* Program; // Указатель на класс-программу
	const CClass* Class; // Указатель на главный класс
	const IStatement* Statement;
	const IExpression* Exp;
	const char *string;
}

%token NEW CLASS EXTENDS THIS RETURN

%token PUBLIC PROTECTED PRIVATE STATIC

%token PRINTLN PRINT

%token INT VOID

%token BOOLEAN TRUE FALSE

%token WHILE IF ELSE

%token <string> NUM ID

%token LPAREN RPAREN

%token LBRACKET RBRACKET

%token LBRACE RBRACE

%token COMMA DOT SEMI

%token COMMENT

%token AND OR

%token PLUS MINUS TIMES

%token MAIN

%token STRING

%token LESS GREATER EQUAL NOT_EQUAL NOT

%token ASSIGN

%right ASSIGN
%left OR
%left AND
%left LESS
%left MINUS, PLUS
%left TIMES, DIVIDE, MOD
%right NOT
%left DOT LBRACKET

// Особые (типизированные) токены
%type <Program> Program
%type <Exp> Exp
%type <Class> MainClass
%type <Class> Class
%type <Class> ClassDeclList
%type <Statement> Statement
%type <Statement> StatementList

%%

Program:
	MainClass { Program = $$ = new CProgram($1, 0); }
	| MainClass ClassDeclList { Program = $$ = new CProgram($1, $2); }
	;

/*
	CClass(CIdExp *class_id, CClass *next_class, CIdExp *main_id, IStatement* code_block)
	If class is Main
	next_class == 0
*/
MainClass: 
	CLASS ID LBRACE 
		PUBLIC STATIC VOID MAIN LPAREN STRING LBRACKET RBRACKET ID RPAREN
		LBRACE 
			StatementList
		RBRACE 
	RBRACE
	{	
		//4th argument: true -- MainClass, false -- ordinary class 
		$$ = new CClass( $2, $12, $15);
	}
	;


/*
CClass(Class *, )

*/
Class: 
	CLASS ID LBRACE Statement RBRACE { $$ = 0 new CClass( $2, $4 ); }
	;

ClassDeclList:
	Class { $$ = new CClass($1, 0); }
	| Class ClassDeclList { $$ = new CClass( $1, $2 ); }
	;

StatementList:
	Statement
	| Statement StatementList
	;

//Список классов
Statement:
	LBRACE StatementList RBRACE { $$ = new CCompoundStm( $2 ); }
	| IF LPAREN Exp RPAREN Statement ELSE Statement { $$ = new CIfStm( $3, $5, $7 ); }
	| WHILE LPAREN Exp RPAREN Statement { $$ = new CWhileStm( $3, $5 ); }
	| PRINT LPAREN Exp RPAREN SEMI { $$ = new CPrintStm( $3 ); }
	| PRINTLN LPAREN Exp RPAREN SEMI { $$ = new CPrintStm( $3 ); }
	| ID ASSIGN Exp SEMI { $$ = new CAssignStm(	 $1, $3 ); }
	| ID LBRACKET Exp RBRACKET ASSIGN Exp SEMI { $$ = new CAssignSubscriptStm( $1, $3, $6 ); }
	;

Function:
	ID LPAREN ARG_LIST RPAREN 
	LBRACE
		StatementList
	RBRACE
	{
		$$ = new CFunction($1, $3, $6);
	}
	;

ARG_LIST:
	TYPE

Exp:
	Exp PLUS Exp { $$ = new COpExp( $1, COpExp::TOperation::PLUS, $3 ); }
	| Exp MINUS Exp { $$ = new COpExp( $1, COpExp::TOperation::Minus, $3 ); }
	| Exp TIMES Exp { $$ = new COpExp( $1, COpExp::TOperation::TIMES, $3 ); }
	| Exp AND Exp { $$ = new CLogicalExp( $1, TLogicalOperation::AND, $3 ); }
	| Exp OR Exp { $$ = new CLogicalExp( $1, TLogicalOperation::AND, $3 ); }

	| Exp LESS Exp { $$ = new CCompareExp( $1, CCompareExp::O_Less, $3 ); }
	//| MINUS Exp %prec T_UMinus { $$ = new CUnariMinusExp( $2 ); } 
	;

%%