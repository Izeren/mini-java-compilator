%code requires {
    #include <stdio.h>
    #include <stdlib.h>
    #include <string>
    #include <stdbool.h>
    #include "shared_ptrs_nodes/Expressions.h"
	#include "shared_ptrs_nodes/Statements.h"
	#include "shared_ptrs_nodes/Classes.h"
	#include <iostream>

    #define YYERROR_VERBOSE 1   
    #define SAVE_LOCATION p->position.firstLine=yylloc.first_line;p->position.firstColumn=yylloc.first_column;p->position.lastLine=yylloc.last_line;p->position.lastColumn=yylloc.last_column;
}

%code {    
	int yylex (void);
	int yyerror ( CProgram **program, const char * );
	extern YYLTYPE yylloc;
	
}

%error-verbose // более подробная информация об ошибке
%verbose // output-файл с правилами грамматики
%parse-param { CProgram** program } // результат работы анализатора
%locations  // Подключаем yylloc без появления @n в коде

%union {

	CProgram* Program; // Указатель на класс-программу
	CClass* Class; // Указатель класс
	CClassList* ClassDeclarationList;
	IStatement* Statement;
	IExpression* Expression;
	CType* Type;
	CField* VarDeclaration;
	CFieldList* VarDeclarationList;
	CArgument* Argument;
	CArgumentList* ArgumentList;
	CArgumentList* NonEmptyArgumentList;
	CMethod* MethodDeclaration;
	CMethodList* MethodDeclarationList;
	CMainMethod* MainMethod;
	CMainClass* MainClass;
	CExpList* ExpressionList;
	CExpList* NonEmptyExpressionList;
	char *string;
	CIdExp* Identifier;
}

%token NEW CLASS EXTENDS THIS RETURN

%token PUBLIC PRIVATE STATIC

%token PRINTLN

%token INT BOOLEAN

%token VOID INT_ARRAY LENGTH

%token TRUE FALSE

%token WHILE IF ELSE

%token <string> NUM

%token <string> ID

%token LPAREN RPAREN

%token LBRACKET RBRACKET

%token LBRACE RBRACE

%token COMMA DOT SEMI

//%token COMMENT

%token AND OR

%token PLUS MINUS TIMES MOD

%token MAIN

%token STRING

%token LESS GREATER NOT

%token ASSIGN

%left LBRACKET DOT LPAREN
%right NOT
%left TIMES MOD
%left MINUS PLUS
%left LESS GREATER
%left AND
%left OR
%right ASSIGN

// Особые (типизированные) токены
%type <Program> Program
%type <Expression> Expression
%type <MainClass> MainClass
%type <Class> Class
%type <ClassDeclarationList> ClassDeclarationList
%type <Statement> Statement
%type <Statement> StatementList
%type <MainMethod> MainMethod
%type <MethodDeclaration> MethodDeclaration
%type <MethodDeclarationList> MethodDeclarationList
%type <VarDeclaration> VarDeclaration
%type <VarDeclarationList> VarDeclarationList
%type <Argument> Argument
%type <Type> Type
%type <ArgumentList> ArgumentList
%type <NonEmptyArgumentList> NonEmptyArgumentList
%type <ExpressionList> ExpressionList
%type <NonEmptyExpressionList> NonEmptyExpressionList
%type <Identifier> Identifier

%%

Program:
	MainClass ClassDeclarationList { 
		auto p = *program = $$ = new CProgram( $1, $2 ); 
		SAVE_LOCATION
	}
	;

MainClass:
	CLASS Identifier LBRACE
		MainMethod
	RBRACE
	{	
		auto p = $$ = new CMainClass( $2, $4 );
		SAVE_LOCATION
	}
	;

MainMethod:
	PUBLIC STATIC VOID MAIN LPAREN STRING LBRACKET RBRACKET Identifier RPAREN
	LBRACE
		VarDeclarationList
		StatementList
	RBRACE 
	{	
		auto p = $$ = new CMainMethod( 0, $9, (CFieldList *) $12,(CCompoundStm *)$13 );
		SAVE_LOCATION
	}
	;

ClassDeclarationList:
	%empty { 
		auto p = $$ = new CClassList();
		SAVE_LOCATION
	}
	|
	ClassDeclarationList Class { auto p = $$ = $1; $1->Add($2); }
	;

Class:
	CLASS Identifier LBRACE
		VarDeclarationList
		MethodDeclarationList
	RBRACE { 
		auto p = $$ = new CClass( $2, 0, $4, $5 );
		SAVE_LOCATION
	}
	| 
	CLASS Identifier EXTENDS Identifier LBRACE
		VarDeclarationList
		MethodDeclarationList
	RBRACE { 
		auto p = $$ = new CClass( $2, $4, $6, $7 ); 
		SAVE_LOCATION
	} 
	;

MethodDeclaration:
	PUBLIC Type Identifier LPAREN ArgumentList RPAREN LBRACE
		VarDeclarationList
		StatementList
		RETURN Expression SEMI
	RBRACE
	//true means public
	{ 
		auto p = $$ = new CMethod( $2, $11, $3, $5, (CFieldList *)$8,(CCompoundStm *)$9, true ); 
		SAVE_LOCATION
	}
	|
	//false means private
	PRIVATE Type Identifier LPAREN ArgumentList RPAREN LBRACE
		VarDeclarationList
		StatementList
		RETURN Expression SEMI
	RBRACE
	{ 
		auto p = $$ = new CMethod( $2, $11, $3, $5, (CFieldList *)$8, (CCompoundStm *)$9, false );
		SAVE_LOCATION 
	}
	;

MethodDeclarationList:
	%empty { 
		auto p = $$ = new CMethodList(); 
		SAVE_LOCATION
	}
	|
	MethodDeclarationList MethodDeclaration { 
		auto p = $$ = $1; $1->Add($2); 
		SAVE_LOCATION
	}
	;

VarDeclaration:
	Type Identifier SEMI {
		auto p = $$ = new CField( $1, $2 ); 
		SAVE_LOCATION
	}
	;

VarDeclarationList:
	%empty { 
		auto p = $$ = new CFieldList(); 
		SAVE_LOCATION
	}
	|
	VarDeclarationList VarDeclaration {
		auto p = $$ = $1; $1->Add( $2 ); 
		SAVE_LOCATION
	}
	;

Argument:
	Type Identifier {
		auto p = $$ = new CArgument( $1, $2 ); 
		SAVE_LOCATION
	}
	;

Type:
	INT_ARRAY { 
		auto p = $$ = new CType( enums::TPrimitiveType::INT_ARRAY ); 
		SAVE_LOCATION
	}
	|
	BOOLEAN { 
		auto p = $$ = new CType( enums::TPrimitiveType::BOOLEAN ); 
		SAVE_LOCATION
	}
	|
	INT { 
		auto p = $$ = new CType( enums::TPrimitiveType::INT ); 
		SAVE_LOCATION
	}
	|
	Identifier { auto p = $$ = new CType( $1 ); SAVE_LOCATION }
	;
NonEmptyArgumentList:
	Argument { auto p = $$ = new CArgumentList($1); SAVE_LOCATION }
	|
	NonEmptyArgumentList COMMA Argument { auto p = $$ = $1; $1->Add($3); SAVE_LOCATION }
	;

ArgumentList:
	%empty { auto p = $$ = new CArgumentList(); SAVE_LOCATION }
	|
	NonEmptyArgumentList { $$ = $1; }
	;

StatementList:
	%empty {$$ = nullptr; }
	|
	Statement StatementList { auto p = $$ = new CCompoundStm($1, $2); SAVE_LOCATION }
	;

Statement:
	LBRACE StatementList RBRACE { $$ = $2; }
	| 
	IF LPAREN Expression RPAREN Statement ELSE Statement { auto p = $$ = new CIfStm( $3, $5, $7 ); SAVE_LOCATION }
	| 
	WHILE LPAREN Expression RPAREN Statement { auto p = $$ = new CWhileStm( $3, $5 ); SAVE_LOCATION }
	| 
	PRINTLN LPAREN Expression RPAREN SEMI { auto p = $$ = new CPrintStm( $3 ); SAVE_LOCATION }
	| 
	Identifier ASSIGN Expression SEMI { auto p = $$ = new CAssignStm( $1, $3 ); SAVE_LOCATION }
	| 
	Identifier LBRACKET Expression RBRACKET ASSIGN Expression SEMI { auto p = $$ = new CAssignSubscriptStm( $1, (CNumExp *)$3, $6 ); SAVE_LOCATION }
	;

Expression:
	Expression PLUS Expression { auto p = $$ = new COpExp( $1, $3, enums::TOperation::PLUS ); SAVE_LOCATION }
	|
	Expression MINUS Expression { auto p = $$ = new COpExp( $1, $3, enums::TOperation::MINUS ); SAVE_LOCATION }
	|
	Expression TIMES Expression { auto p = $$ = new COpExp( $1, $3, enums::TOperation::MULTIPLY ); SAVE_LOCATION }
	|
	Expression AND Expression { auto p = $$ = new CLogOpExp( $1, $3, enums::TLogicalOperation::AND ); SAVE_LOCATION }
	|
	Expression OR Expression { auto p = $$ = new CLogOpExp( $1, $3, enums::TLogicalOperation::OR ); SAVE_LOCATION }
	|
	Expression LESS Expression { auto p = $$ = new CCompExp( $1, $3, enums::TCompareOperation::LESS ); SAVE_LOCATION }
	|
	Expression GREATER Expression { auto p = $$ = new CCompExp( $1, $3, enums::TCompareOperation::GREATER ); SAVE_LOCATION }
	|
	Expression MOD Expression { auto p = $$ = new COpExp( $1, $3, enums::TOperation::MOD ); SAVE_LOCATION }
	|
	Expression LBRACKET Expression RBRACKET { auto p = $$ = new CByIndexExpression($1, $3); SAVE_LOCATION }
	|
	Expression DOT LENGTH { auto p = $$ = new CGetLengthExp( (CArrayExpression*) $1 ); SAVE_LOCATION }
	|
	Identifier DOT Identifier LPAREN ExpressionList RPAREN { auto p = $$ = new CCallMethodExp( $1, $3, (CExpList*) $5) ; SAVE_LOCATION }
	|
	THIS DOT Identifier LPAREN ExpressionList RPAREN { auto p = $$ = new CCallMethodExp( 0, $3, (CExpList*) $5) ; SAVE_LOCATION }
	|
	MINUS NUM { auto p = $$ = new CNumExp( (std::string("-") + std::string($2)).c_str() ); SAVE_LOCATION }
	|
	NUM { auto p = $$ = new CNumExp($1); SAVE_LOCATION }
	|
	TRUE { auto p = $$ = new CLogExp(true); SAVE_LOCATION }
	|
	FALSE { auto p = $$ = new CLogExp(false); SAVE_LOCATION }
	|
	Identifier { auto p = $$ = $1; SAVE_LOCATION }
	|
	THIS DOT Identifier { auto p = $$ = new CThisExpression( $3 ); SAVE_LOCATION }
	|
	NEW INT LBRACKET Expression RBRACKET { auto p = $$ = new CArrayExpression($4); SAVE_LOCATION }
	|
	NEW Identifier LPAREN  RPAREN { auto p = $$ = new CNewIdentifier( $2 ); SAVE_LOCATION }
	|
	NOT Expression { auto p = $$ = new CNegativeExpression($2); SAVE_LOCATION }
	|
	LPAREN Expression RPAREN { $$ = $2; }	
	;

NonEmptyExpressionList:
	Expression { auto p = $$ = new CExpList($1); SAVE_LOCATION }
	|
	NonEmptyExpressionList COMMA Expression { auto p = $$ = $1; $1->Add($3); SAVE_LOCATION }
	;

ExpressionList:
	%empty { auto p = $$ = new CExpList(); SAVE_LOCATION }
	|
	NonEmptyExpressionList { $$ = $1; }
	;

Identifier:
	ID { auto p = $$ = new CIdExp( $1 ); SAVE_LOCATION }
	;

%%

int yyerror(std::string s) {
  return -1;
}

int yyerror(CProgram **program, const char *s) {
	std::cout << s << "\n";
	std::cout << "Something went wrong\n";
	return yyerror(std::string(s));
}