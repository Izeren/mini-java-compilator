%{
    #include <stdio.h>
    #include <stdlib.h>
    #include <string>
    #include <stdbool.h>
       
    #define YYERROR_VERBOSE 1        
%}

%code {
int yylex (void);
void yyerror ( const IProgram*&, char const * );
}

%error-verbose // более подробная информация об ошибке
%verbose // output-файл с правилами грамматики
%parse-param { const IProgram*& program } // результат работы анализатора
%locations  // Подключаем yylloc без появления @n в коде

%union {

	CProgram* Program; // Указатель на класс-программу
	CClass* Class; // Указатель на главный класс
	IStatement* Statement;
	IExpressionression* Expression;
	char *string;
	int IntValue;
}

%token NEW CLASS EXTENDS THIS RETURN

%token PUBLIC PRIVATE STATIC

%token PRINTLN

%token <string> INT BOOLEAN

%token VOID INT_ARRAY LENGTH

%token TRUE FALSE

%token WHILE IF ELSE

%token <IntValue> NUM

%token <string> ID

%token LPAREN RPAREN

%token LBRACKET RBRACKET

%token LBRACE RBRACE

%token COMMA DOT SEMI

%token COMMENT

%token AND OR

%token PLUS MINUS TIMES MOD

%token MAIN

%token STRING

%token LESS GREATER NOT

%token ASSIGN

%right ASSIGN
%left OR
%left AND
%left LESS
%left MINUS, PLUS
%left TIMES, MOD
%right NOT
%left DOT LBRACKET

// Особые (типизированные) токены
%type <Program> Program
%type <Expression> Expression
%type <Class> MainClass
%type <Class> Class
%type <Class> ClassList
%type <Statement> Statement
%type <Statement> StatementList

%%

Program:
	MainClass { Program = $$ = new CProgram( $1, 0 ); }
	|
	MainClass ClassList { Program = $$ = new CProgram( $1, $2 ); }
	;

MainClass:
	CLASS ID LBRACE 
		MainMethod
	RBRACE
	{	
		$$ = new CMainClass( $2, $4 );
	}
	;

MainMethod:
	PUBLIC STATIC VOID MAIN LPAREN STRING LBRACKET RBRACKET ID RPAREN
	LBRACE
		StatementList
	RBRACE 
	{	
		$$ = new CMainMethod( 0, 0, $12 );
	}
	;

ClassDeclarationList:
	{ $$ = nullptr; }
	|
	Class ClassDeclarationList { $$ = new CClassDeclarationList( $1, $2 ); }
	;

Class:
	CLASS ID LBRACE
		VarDeclaratitionList
		MethodDeclarationList
	RBRACE { $$ = new CClass( $2, 0, $4, $5 ); }
	| 
	CLASS ID EXTENDS ID LBRACE
		VarDeclaratitionList
		MethodDeclarationList
	RBRACE { $$ = new CClass( $2, $4, $6, $7 ); } 
	;

MethodDeclaration:
	PUBLIC Type ID LPAREN ArgumentList RPAREN LBRACE 
		StatementList
		RETURN Expression SEMI
	RBRACE
	{ $$ = new CMethod( $2, $3, $5, $8 ); }
	|
	PRIVATE Type ID LPAREN ArgumentList RPAREN LBRACE 
		StatementList
		RETURN Expression SEMI
	RBRACE
	{ $$ = new CMethod( $2, $3, $5, $8 ); }
	;

MethodDeclarationList:
	{ $$ = nullptr; }
	|
	MethodDeclaration MethodDeclarationList { $$ = CMethodList( $1, $2 ); }
	;

VarDeclaration:
	Type ID SEMI { $$ = new CField( $1, $2 ); }
	;

VarDeclaratitionList:
	{ $$ = nullptr; }
	|
	VarDeclaration VarDeclaratitionList { $$ = new CFieldList( $1, $2 ); }
	;

Argument:
	Type ID { $$ = new CArgument( $1, $2 ); }
	;

Type:
	INT LBRACKET RBRACKET { $$ = new CType( $1 ); }
	|
	BOOLEAN { $$ = new CType( $1 ); }
	|
	INT { $$ = new CType( $1 ); }
	|
	ID { $$ = new CType( $1 ); }
	;

ArgumentList:
	{ $$ = nullptr; }
	|
	Argument ArgumentList { $$ = CArgumentList( $1, $2 ); }
	;

StatementList:
	{$$ = nullptr; }
	|
	Statement StatementList { $$ = new CCompoundStm($1, $2); }
	;

Statement:
	LBRACE StatementList RBRACE { $$ = $2 }
	| 
	IF LPAREN Expression RPAREN Statement ELSE Statement { $$ = new CIfStm( $3, $5, $7 ); }
	| 
	WHILE LPAREN Expression RPAREN Statement { $$ = new CWhileStm( $3, $5 ); }
	| 
	PRINTLN LPAREN Expression RPAREN SEMI { $$ = new CPrintStm( $3 ); }
	| 
	ID ASSIGN Expression SEMI { $$ = new CAssignStm( $1, $3 ); }
	| 
	ID LBRACKET Expression RBRACKET ASSIGN Expression SEMI { $$ = new CAssignSubscriptStm( $1, $3, $6 ); }
	;

Expression:
	Expression PLUS Expression { $$ = new COpExpression( $1, COpExpression::TOperation::PLUS, $3 ); }
	|
	Expression MINUS Expression { $$ = new COpExpression( $1, COpExpression::TOperation::Minus, $3 ); }
	|
	Expression TIMES Expression { $$ = new COpExpression( $1, COpExpression::TOperation::TIMES, $3 ); }
	|
	Expression AND Expression { $$ = new CLogicalExpression( $1, TLogicalOperation::AND, $3 ); }
	|
	Expression OR Expression { $$ = new CLogicalExpression( $1, TLogicalOperation::OR, $3 ); }
	|
	Expression LESS Expression { $$ = new CCompareExpression( $1, CCompareExpression::LESS, $3 ); }
	|
	Expression GREATER Expression { $$ = new CCompareExpression( $1, CCompareExpression::GREATER, $3 ); }
	|
	Expression MOD Expression { $$ = new COpExpression( $1, COpExpression::TOperation::MOD, $3 ); }
	|
	Expression LBRACKET Expression RBRACKET { $$ = ??? }
	|
	Expression DOT LENGTH { $$ = ??? }
	|
	Expression DOT ID LPAREN ExpressionList RPAREN { $$ = ??? }
	|
	NUM { $$ = $1 }
	|
	TRUE { $$ = $1 }
	|
	FALSE { $$ = $1 }
	|
	ID { $$ = $1 }
	|
	THIS { $$ = $1 }
	|
	NEW INT LBRACKET Expression RBRACKET { $$ = ??? }
	|
	NEW ID LPAREN RPAREN { $$ = ??? }
	|
	NOT Expression { $$ = ??? }
	|
	LPAREN Expression RPAREN { $$ = $2 }	
	;

ExpressionList:
	{ $$ = nullptr; }
	|
	Expression ExpressionList { $$ = ??? }

%%